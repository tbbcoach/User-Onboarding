/**
 * Created by yuji on 2015/10/28.
 */
'use strict';
const lang = require('./lang');

class Tmp extends Array {
  constructor(cache) {
    super();
    this.cache = cache;
  }

  push(value) {
    super.push(value);
    this.cache.add(value);
  }

  init() {
    this.length = 0;
  }
}

/**
 *Tested
 * 生成有序依赖
 * @param fileList
 * @param mapRes
 */
const orderlyDeps = (fileList, mapRes) => {
  const cache = new Set();
  let orderlyDependencies = [];

  const tmp = new Tmp(cache);

  //  递归地获取依赖，依赖层次逐步加深，所以如果没有循环依赖的话，后面的不会对前面有依赖
  const cal = (item, mapResource, tempCache) => {
    if (!cache.has(item)) {
      tempCache.push(item);
      lang.mapSet(mapResource.deps(item), value => cal(value, mapResource, tempCache));
    }
  };

  lang.mapSet(fileList, fileName => {
    if (!cache.has(fileName)) {
      tmp.init();
      cal(fileName, mapRes, tmp);
      orderlyDependencies = orderlyDependencies.concat(tmp.reverse().slice());
    }
  });
  return orderlyDependencies;
};

const recalculateFileToCompileList = (fileList, mapRev) => {
  const dependenciesMap = mapRev.map;
  const fileSet = new Set(fileList);
  lang.mapSet(fileSet, (item) => {
    if (lang.hasProp(dependenciesMap, item)) {
      lang.mapSet(dependenciesMap[item], (fileName) => fileSet.add(fileName));
    }
  });
  return fileSet;
};

exports.orderlyDeps = orderlyDeps;

exports.recalFileList = recalculateFileToCompileList;
