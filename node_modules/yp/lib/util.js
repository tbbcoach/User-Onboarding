/**
 * Created by yuji on 2015/10/28.
 */

'use strict';
const crypto = require('crypto');
const fs = require('fs');
const path = require('./path');
const mkdirp = require('mkdirp');
const config = require('./config');
const log = require('./log');
const os = require('./os');
const exec = require('child_process').exec;
const util = exports;

//  md5函数封装
function md5(buff) {
  const m = crypto.createHash('md5');
  m.update(buff);
  return m.digest('hex');
}
/**
 * 生成md5后缀
 * 取七位
 * @param buffer
 * @returns {*}
 */
util.md5Suffix = buffer => parseInt(md5(buffer), 16).toString(36).slice(-7);

const fileExt2Type = {
  '.css': 'css',
  '.html': 'html',
  '.htm': 'template',
  '.js': 'javascript',
  '.tpl': 'template',
  '.json': 'json',
  '.png': 'image/png',
  '.gif': 'image/gif',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.sass': 'sass',
  '.scss': 'sass',
  '.jade': 'jade',
  '.md': 'markdown',
  '.ejs': 'ejs',
};


//  文件操作相关

util.getFileType = extname => fileExt2Type[extname] || 'unknown';

const judgeShouldIgnore = (ignoreReg, item, outdir) => {
  if (ignoreReg.test(item)) {
    if (config.leaveFileLog) {
      log.out(path.join(outdir, item));
    }
    // cb(item);
    return false;
  }
  return true;
};

//  会将忽略的文件输出
util.filter = function (fileList, requireDirs, ignoreDirs, leftExtra = () => {}) {
  if (requireDirs.length !== ignoreDirs.length) {
    throw new Error("Wrong config!\n Dirs'es length should equals ignore_dirs'es length");
  }
  const requireRegex = requireDirs.map(dirName => new RegExp(`^${dirName}`));
  const ignoreRegex = ignoreDirs.map(ignores => ignores.map(ignore => new RegExp(ignore)));

  return fileList.filter((item) => (
    requireRegex.reduce((past, requireReg, index) => {
      if (past) {
        return true;
      }
      if (!requireReg.test(item)) {
        return false;
      }
      return ignoreRegex[index].reduce((before, ignoreReg) =>
        !before ? false : judgeShouldIgnore(ignoreReg, item, config.outdir, leftExtra), true);
    }, false)
  ));
};

const generateDefaultOutPath = filePath =>
  path.join(config.rootPath, '..', config.outdir, filePath);

//  利用copy命令执行文件和文件夹复制
// 移除该功能
util.executeCopy = function (filepath, outpath, cb) {
  return;
  const fullPath = path.join(config.rootPath, filepath);
  const finalOutpath = outpath || generateDefaultOutPath(filepath);
  if (fs.lstatSync(fullPath).isDirectory()) {
    // 如果管道连接两个命令，可以是并行的，要保证顺序可以用&&
    const command = [os.mkdirCommand + finalOutpath,
      os.cpCommand + path.join(config.rootPath, filepath, '*  ') + finalOutpath].join(' && ');
    log.log(command);
    exec(command, cb);
  }
};


util.copyFile2OutDir = rawPath => {
  const paths = path.toOsSpecifiedPath(rawPath);
  const fullName = generateDefaultOutPath(paths);
  try {
    mkdirp.sync(path.dirname(fullName));
  } catch (e) {
    log.error(e);
  }
  fs.writeFileSync(fullName, fs.readFileSync(path.join(config.rootPath, paths)));
  return false;
};

